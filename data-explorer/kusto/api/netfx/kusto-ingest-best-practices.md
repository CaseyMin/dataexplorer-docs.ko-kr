---
title: Kusto 수집 클라이언트 라이브러리-모범 사례-Azure 데이터 탐색기 | Microsoft Docs
description: 이 문서에서는 Azure 데이터 탐색기의 클라이언트 라이브러리 모범 사례를 수집 하는 Kusto를 설명 합니다.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 08/16/2019
ms.openlocfilehash: 2369d352e316f1d9b49de71fb197507280598754
ms.sourcegitcommit: 1faf502280ebda268cdfbeec2e8ef3d582dfc23e
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/01/2020
ms.locfileid: "82617938"
---
# <a name="kusto-ingest-client-library---best-practices"></a>Kusto 수집 클라이언트 라이브러리-모범 사례

## <a name="choosing-the-right-ingestclient-flavor"></a>올바른 IngestClient 버전 선택

[KustoQueuedIngestClient](kusto-ingest-client-reference.md#interface-ikustoqueuedingestclient) 를 사용 하는 것은 권장 되는 네이티브 데이터 수집 모드입니다. 이유는 다음과 같습니다.
* 엔진 가동 중지 (예: 배포 중) 중에는 직접 수집할 수 없습니다. 반면 대기 중인 수집 모드에서 요청은 Azure 큐에 유지 되 고 데이터 관리 서비스는 필요에 따라 다시 시도 됩니다.
* 데이터 관리 서비스는 수집 요청으로 엔진을 오버 로드 하지 않습니다. 이 컨트롤을 재정의 하는 경우 (예: 직접 수집을 사용 하는 경우) 수집 및 쿼리와 같은 엔진 성능에 심각한 영향을 줄 수 있습니다
* 데이터 관리는 여러 수집 요청을 집계 하 여 만들 초기 분할 된 분할 (익스텐트)의 크기를 최적화 합니다.
* 각 수집에 대 한 피드백을 얻는 것은 쉽습니다.

## <a name="tracking-ingest-operation-status"></a>수집 작업 상태 추적

[수집 작업 상태 추적](kusto-ingest-client-status.md#tracking-ingestion-status-kustoqueuedingestclient) 은 유용한 기능입니다. 그러나 보고 성공을 위해이 기능을 설정 하는 것은 서비스를 약화 시키는 범위에 쉽게 악용 수 있습니다.

> [!WARNING]
> 대량 볼륨 데이터 스트림에 대 한 모든 수집 요청에 대해 긍정 알림을 설정 하는 것은 기본 xStore 리소스에 극단적인 부하를 주기 때문에 피해 야 합니다. 추가 로드로 인해 수집 대기 시간이 늘어나고 클러스터의 응답성이 완전 하지 않습니다.

## <a name="optimizing-for-throughput"></a>처리량 최적화

* 수집은 대량으로 수행 되는 경우 가장 잘 작동 합니다. 최소 리소스를 소비 하 고, 가장 COGS 최적화 된 데이터 분할를 생성 하 고, 최상의 데이터 아티팩트를 생성 합니다. 일반적으로 Kusto. 수집 라이브러리를 사용 하 여 데이터를 수집 하거나 엔진에 직접 데이터를 전송 하는 고객에 게 100 MB의 일괄 처리로 데이터를 전송 하는 것이 좋습니다 **(압축 되지 않음)** .
* 엔진에서 직접 작업 하는 경우 수집 프로세스에서 사용 하는 메모리의 양을 줄이기 위해 상한에 중요 한 제한이 있습니다. 

> [!NOTE]
> 클래스를 사용 `KustoQueuedIngestClient` 하는 경우 너무 많은 양의 데이터 블록이 더 작은 청크로 분할 되 고 이러한 작은 청크는 엔진에 도달 하기 전에 특정 수준으로 집계 됩니다.

* 수집 데이터 크기에 대 한 한도는 중요 하지만 그다지 중요 하지 않습니다. 수집는 항상 작은 일괄 처리로 데이터를 처리 한 다음, 대량 일괄 처리를 사용 하는 것 보다 약간 효율적이 지는 않지만 완벽 합니다. 또한 `KustoQueuedIngestClient` 클래스는 많은 양의 데이터를 수집 해야 하는 고객에 대 한 문제를 해결 하 고 엔진에 전송 하기 전에 대량의 청크로 일괄 처리할 수 없습니다.

## <a name="factors-impacting-ingestion-throughput"></a>수집 처리량에 영향을 주는 요소

여러 요인이 수집 처리량에 영향을 줄 수 있습니다. 수집 파이프라인을 계획할 때 COGs에 상당한 영향을 미칠 수 있는 다음 사항을 평가 해야 합니다.

| 고려 사항에 대 한 요소 |  Decription                                                                                               |
|--------------------------|-----------------------------------------------------------------------------------------------------------|
| 데이터 형식              | CSV는 수집할 가장 빠른 형식이 며, JSON은 일반적으로 동일한 데이터 볼륨에 대해 2x 또는 3 배 더 오래 걸립니다.|
| 표 너비              | 정말 필요한 데이터만 수집 해야 합니다. 테이블이 더 광범위 하 고 더 많은 열을 인코딩 및 인덱싱해야 하므로 처리량이 낮아집니다. 수집 매핑을 제공 하 여 수집 가져오는 필드를 제어할 수 있습니다.|
| 원본 데이터 위치     | 수집 속도를 높이기 위해 지역 간 읽기를 방지 합니다.                                                       |
| 클러스터에서 로드      | 클러스터에 높은 쿼리 부하가 발생 하면 ingestions를 완료 하는 데 시간이 오래 걸리고 처리량이 줄어듭니다.|
| 수집 패턴        | 클러스터가 최대 1GB (를 사용 `KustoQueuedIngestClient`하 여 처리 됨)의 일괄 처리로 처리 되는 경우 수집이 최적으로 이루어집니다. |

## <a name="optimizing-for-cogs"></a>COGS 최적화

Kusto 클라이언트 라이브러리를 사용 하 여 데이터를 Kusto에 수집 하면 가장 저렴 하 고 강력 하 게 옵션을 유지할 수 있습니다. Microsoft는 고객에 게 수집 방법을 검토 하 고 blob 트랜잭션을 크게 비용 효율적으로 만드는 Azure Storage 가격 책정을 활용 하도록 합니다.

Azure 데이터 탐색기 수집 비용을 보다 효율적으로 제어 하 고 월별 요금을 줄이려면 수집 데이터 청크 수를 제한 합니다 (파일/b a s/스트림/스트림).

* **수집 큰 데이터 청크 (최대 1gb의 압축 되지 않은 데이터)를 사용 하**는 것이 좋습니다. 
    많은 팀에서 수십 억 개의 작은 데이터 청크를 수집 하 여 대기 시간이 짧고 매우 비효율적 이며 비용이 많이 듭니다. 클라이언트 쪽에서의 모든 일괄 처리 양은 도움이 됩니다. 
* **정확 하 고 압축 되지 않은 데이터 크기로 Kusto를 제공**해야 합니다.
    이렇게 하지 않으면 추가 저장소 트랜잭션이 발생할 수 있습니다.
* `FlushImmediately` 플래그가로 설정 된 수집에 대 한 `true`데이터를 전송 하거나 태그가 설정 된 `ingest-by` / `drop-by` 작은 청크를 보내는 것을 **방지** 합니다.
    이러한 방법을 사용 하면 서비스에서 수집 하는 동안 데이터를 제대로 집계 하지 못하게 되 고 수집 후에 불필요 한 저장소 트랜잭션이 발생 하므로 COGS에 영향을 줍니다.
    
    또한 이러한 쿼리를 과도 하 게 사용 하면 클러스터의 수집 및/또는 쿼리 성능이 저하 될 수 있습니다.
    
