---
title: Kusto 수집 클라이언트 라이브러리 모범 사례-Azure 데이터 탐색기
description: 이 문서에서는 Kusto 수집 클라이언트 라이브러리에 대 한 모범 사례를 설명 합니다.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 08/16/2019
ms.openlocfilehash: d02d030a6deb468a4804c68965466e1917858be9
ms.sourcegitcommit: fd3bf300811243fc6ae47a309e24027d50f67d7e
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/13/2020
ms.locfileid: "83382338"
---
# <a name="kusto-ingest-client-library---best-practices"></a>Kusto 수집 클라이언트 라이브러리-모범 사례

## <a name="select-the-right-ingestclient-flavor"></a>올바른 IngestClient 버전 선택

[KustoQueuedIngestClient](kusto-ingest-client-reference.md#interface-ikustoqueuedingestclient)를 사용 하는 것이 좋습니다. 이유는 다음과 같습니다.
* 배포 하는 동안와 같이 엔진 가동 중지 시간 중에는 직접 수집 하지 못할 수 있습니다. 대기 중인 수집 모드에서 요청은 Azure 큐에 유지 되 고 데이터 관리 서비스는 필요에 따라 다시 시도 합니다.
* 데이터 관리 서비스는 엔진이 수집 요청을 오버 로드 하는 것을 유지 합니다. 예를 들어 직접 수집을 사용 하 여이 컨트롤을 재정의 하면 엔진 수집 및 쿼리 성능에 심각한 영향을 줄 수 있습니다.
* 데이터 관리은 수집을 위해 여러 요청을 집계 합니다. 집계는 만들 초기 분할 된 분할 (익스텐트)의 크기를 최적화 합니다.
* 각 수집에 대 한 피드백을 쉽게 얻을 수 있습니다.

## <a name="avoid-tracking-ingest-operation-status"></a>수집 작업 상태 추적 방지

[수집 작업 상태를 추적](kusto-ingest-client-status.md#tracking-ingestion-status-kustoqueuedingestclient) 하는 것이 유용 합니다. 그러나 큰 볼륨 데이터 스트림의 경우 모든 수집 요청에 대해 긍정 알림을 켜는 것은 피해 야 합니다. 이러한 추적을 통해 수집 대기 시간을 증가 시키고 클러스터 비 응답성을 높일 수 있는 기본 xStore 리소스에 부하가 발생 합니다.

## <a name="optimizing-for-throughput"></a>처리량 최적화

수집은 대량으로 수행 되는 경우 가장 잘 작동 합니다. 
* 최소 리소스를 사용 합니다.
* 가장 COGS 최적화 된 데이터 분할를 생성 하 고 최상의 데이터 트랜잭션을 생성 합니다.

Kusto. 수집 라이브러리를 사용 하 여 데이터를 수집 하거나 엔진에 직접 데이터를 전송 하는 고객에 게 **100 MB** 의 일괄 처리로 데이터를 전송 하는 것이 좋습니다 **(압축 되지 않음)** .
* 엔진에서 직접 작업 하는 경우 수집 프로세스에서 사용 하는 메모리의 양을 줄이기 위해 상한에 중요 한 제한이 있습니다. 

> [!NOTE]
> 클래스를 사용 하는 경우 `KustoQueuedIngestClient` 너무 많은 양의 데이터 블록이 더 작은 청크로 분할 되 고 이러한 작은 청크는 엔진에 도달 하기 전에 특정 수준으로 집계 됩니다.

* 수집 데이터 크기에 대 한 한도는 중요 하지만 그다지 중요 하지 않습니다. 수집는 항상 작은 일괄 처리로 데이터를 처리 한 다음, 대량 일괄 처리를 사용 하는 것 보다 약간 효율적이 지는 않지만 완벽 합니다. `KustoQueuedIngestClient`또한 클래스는 많은 양의 데이터를 수집 해야 하는 고객에 대 한 문제를 해결 하 고 엔진에 전송 하기 전에 대량의 청크로 일괄 처리할 수 없습니다.

## <a name="other-factors-that-impact-ingestion-throughput"></a>수집 처리량에 영향을 주는 다른 요소

여러 요인이 수집 처리량에 영향을 줄 수 있습니다. 수집 파이프라인을 계획할 때 COGs에 상당한 영향을 미칠 수 있는 다음 사항을 평가 해야 합니다.

| 고려 사항에 대 한 요소 |  Description                                                                                              |
|--------------------------|-----------------------------------------------------------------------------------------------------------|
| 데이터 형식              | CSV는 수집할 가장 빠른 형식입니다. JSON은 일반적으로 동일한 데이터 볼륨에 대해 2x 또는 3 배 더 오래 걸립니다.|
| 표 너비              | 정말 필요한 데이터만 수집 해야 합니다. 테이블이 더 넓어집니다. 더 많은 열을 인코딩하고 인덱싱해야 하므로 처리량이 줄어듭니다. 수집 매핑을 제공 하 여 수집 가져오는 필드를 제어할 수 있습니다.       |
| 원본 데이터 위치     | 수집 속도를 높이기 위해 지역 간 읽기를 방지 합니다.                                                       |
| 클러스터에서 로드      | 클러스터에 높은 쿼리 부하가 발생 하면 ingestions를 완료 하는 데 시간이 오래 걸리고 처리량이 줄어듭니다.|

## <a name="optimizing-for-cogs"></a>COGS 최적화

Kusto 클라이언트 라이브러리를 사용 하 여 Azure 데이터 탐색기에 데이터를 수집 하는 것은 저렴 하 고 가장 강력 하 고 뛰어난 옵션입니다. Microsoft는 고객에 게 수집 방법을 검토 하 고 blob 트랜잭션을 크게 비용 효율적으로 만드는 Azure Storage 가격 책정을 활용 하도록 합니다.

* **수집 데이터 청크 수를 제한**합니다.
    Azure 데이터 탐색기 수집 비용을 보다 효율적으로 제어 하 고 월별 요금을 줄이려면 수집 데이터 청크 수를 제한 합니다 (파일/b a s/스트림/스트림).
* **대량의 데이터 청크 수집 (최대 1gb의 압축 되지 않은 데이터)** 
    많은 팀이 비효율적 이며 비용이 많이 드는 수십 개의 작은 데이터 청크를 수집 하 여 짧은 대기 시간을 실현 하려고 합니다. 
* **일괄 처리**. 클라이언트 쪽에서의 모든 일괄 처리 크기는 최적화가 향상 됩니다. 
* **정확 하 고 압축 되지 않은 데이터 크기를 사용 하 여 수집 클라이언트를 제공 합니다.**
    이렇게 하지 않으면 추가 저장소 트랜잭션이 발생할 수 있습니다.
* 플래그가로 설정 된 수집에 대 한 데이터를 보내지 **않도록** `FlushImmediately` `true` 합니다. 또한 태그가 설정 된 작은 청크는 보내지 않습니다 `ingest-by` / `drop-by` . 이러한 방법을 사용 하는 경우 다음 작업을 수행 합니다.
     * 수집 중에 서비스가 데이터를 제대로 집계 하지 못하도록 방지
     * 수집을 수행 하는 동안 불필요 한 저장소 트랜잭션 발생
     * COGS 영향
     * 과도 하 게 사용 되는 경우 클러스터의 수집 또는 쿼리 성능이 저하 될 수 있습니다.
