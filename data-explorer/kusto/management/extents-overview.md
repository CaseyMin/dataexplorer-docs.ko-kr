---
title: 익스텐트(데이터 샤드) - Azure 데이터 탐색기 | 마이크로 소프트 문서
description: 이 문서에서는 Azure 데이터 탐색기의 익스텐트(데이터 샤드)에 대해 설명합니다.
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 03/13/2020
ms.openlocfilehash: 16afb2dc7d2310e9e63ec3465937ac84c96b27e4
ms.sourcegitcommit: 47a002b7032a05ef67c4e5e12de7720062645e9e
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/15/2020
ms.locfileid: "81521015"
---
# <a name="extents-data-shards"></a>익스텐트(데이터 샤드)

## <a name="overview"></a>개요

Kusto는 엄청난 수의 레코드 (행)와 많은 데이터를 가진 테이블을 지원하도록 만들어졌습니다. 이러한 큰 테이블을 처리할 수 있도록 Kusto는 각 테이블의 데이터를 데이터 **샤드** 또는 **익스텐션이라고** 하는 더 작은 "정제"로 나누어 모든 테이블익스텐트의 조합이 테이블의 데이터를 보유하도록 합니다. 그런 다음 개별 익스텐트(익스텐디)가 단일 노드의 용량보다 작게 유지되고 범위가 클러스터의 노드에 분산되어 확장이 수행됩니다. 

어느 정도를 일종의 미니 테이블이라고 생각할 수 있습니다. 익스텐트에는 메타데이터(익스텐트내데이터의 스키마를 표시하고 해당 범위의 데이터와 연관된 선택적 태그 및 해당 범위의 데이터 및 선택적 태그와 같은 추가 정보를 표시)가 있습니다. 또한 익스텐트에는 일반적으로 Kusto가 익스텐션의 각 데이터 열에 대한 인덱스, 열 데이터가 인코딩된 경우 인코딩 사전과 같이 데이터를 효율적으로 쿼리할 수 있는 정보가 있습니다. 따라서 테이블의 데이터는 테이블 익스텐트의 모든 데이터의 결합입니다.

범위는 *변경할 수 없습니다.* 익스텐트가 만들어지면 익스텐트가 수정되지 않으며 익스텐트가 쿼리되거나 다른 노드로 다시 할당되거나 테이블에서 삭제될 수 있습니다. 데이터 수정은 하나 이상의 새 익스텐션을 만들고 이전 익스텐션을 새 익스텐트로 트랜잭션으로 교환하여 발생합니다.

익스텐트는 물리적으로 열에 정렬된 레코드 컬렉션을 보유합니다.
이 **기술(columnar store라고**함)을 사용하면 데이터를 효율적으로 인코딩하고 압축할 수 있으며(동일한 열의 다른 값이 서로 "유사"하기 때문에) 쿼리에 사용되는 열만 로드해야 하기 때문에 큰 범위의 데이터를 쿼리하는 것이 더 효율적입니다. 내부적으로 익스텐스의 각 데이터 열은 세그먼트로 세분화되고 세그먼트는 블록으로 세분화됩니다. 이 분할(쿼리에서는 관찰할 수 없는)을 통해 Kusto는 열 압축 및 인덱싱을 최적화할 수 있습니다.

쿼리 효율성을 유지하기 위해 더 작은 익스텐스가 더 큰 익스텐디로 병합됩니다.
이 프로세스는 구성된 [병합 정책](mergepolicy.md) 및 [샤딩 정책에](shardingpolicy.md)따라 백그라운드 프로세스로 Kusto에 의해 자동으로 수행됩니다.
익스텐디를 병합하면 추적할 수 있는 많은 수의 익스텐디를 갖는 관리 오버헤드가 줄어들지만, 더 중요한 것은 Kusto가 인덱스를 최적화하고 압축을 개선할 수 있다는 것입니다. 범위가 크기와 같은 특정 한도에 도달하면 병합이 중지되면 특정 포인트 병합 범위가 효율성을 증가시키는 대신 감소합니다.

데이터 [분할 정책이](partitioningpolicy.md) 테이블에 정의되면 익스텐션이 생성된 후 다른 백그라운드 프로세스(사후 수집)를 거치게 됩니다. 이 프로세스는 원본 범위의 데이터를 다시 수집하고 테이블의 *파티션 키인* 열 값이 모두 동일한 파티션에 속하는 *동종* 익스텐션을 만듭니다. 정책에 *해시 파티션 키가*포함된 경우 동일한 파티션에 속하는 모든 균일한 익스텐션이 클러스터의 동일한 데이터 노드에 할당됩니다.

> [!NOTE]
> 익스텐트 태그 병합, 익스텐트 태그 변경 등과 같은 범위 수준 작업은 기존 익스텐스를 수정하지 않습니다.
> 대신 기존 소스 익스텐트에 따라 이러한 작업에서 새 익스텐다가 만들어지고 이러한 새 익스텐은 단일 트랜잭션에서 조상을 대체합니다.

따라서 익스텐스의 일반적인 "수명 주기"는 다음과 같은 것입니다.

1. 익스텐션은 **인기** 작업에 의해 생성됩니다.
2. 익스텐스는 다른 익스텐스와 병합됩니다. 병합되는 익스텐션이 작으면 Kusto는 실제로 해당 익스텐트 프로세스를 수행합니다(이 익스텐트은 **다시 작성됨).** 익스텐스가 특정 크기에 도달하면 인덱스에 대해서만 병합이 수행되고 저장소에 있는 익스텐트의 데이터 아티팩트는 수정되지 않습니다.
3. 병합된 익스텐트(다른 병합된 익스텐트 등으로 계보를 추적하는 익스텐트 범위)는 보존 정책으로 인해 결국 삭제됩니다. 시간(이전 x 시간/일)을 기준으로 익스텐션이 삭제되면 병합된 익스텐트 내부의 최신 익스텐션의 생성 날짜가 계산으로 전환됩니다.

## <a name="extent-ingestion-time"></a>익스텐션 인데시

각 익스텐트에 대한 더 중요한 정보 중 하나는 수집 시간입니다. 이 시간은 Kusto에서 다음을 위해 사용됩니다.

1. 보존(이전에 섭취한 범위는 더 일찍 삭제됩니다).
2. 캐싱(최근에 섭취한 익스텐트는 더 뜨거워질 것입니다).
3. 샘플링(와 같은 `take`쿼리 작업을 사용하는 경우 최근 익스텐스가 선호됩니다).

실제로 Kusto는 익스텐트당 `MinCreatedOn` 두 `MaxCreatedOn`개의 `datetime` 값을 추적합니다.
이러한 값은 동일하게 시작되지만 익스텐스가 다른 익스텐트와 병합될 때 결과 익스텐트값은 병합된 모든 익스텐트에 대한 최소값과 최대값입니다.

익스텐트의 섭취 시간은 다음 세 가지 방법 중 하나로 설정할 수 있습니다.

1. 일반적으로 인시레이션을 수행하는 노드는 로컬 클럭에 따라 이 값을 설정합니다.
2. 인기 **시간 정책이** 테이블에 설정된 경우 인과 작업을 수행하는 노드는 클러스터의 로컬 클럭에 따라 이 값을 설정하여 이후의 모든 인기생성이 더 높은 처리 시간 값을 갖도록 보장합니다.
3. 클라이언트가 이 시간을 설정할 수 있습니다. 예를 들어 클라이언트가 데이터를 다시 수집하려고 하고 다시 수집한 데이터가 보존 목적으로 늦게 도착한 것처럼 나타나지 않도록 하는 경우에 유용합니다.    

## <a name="extent-tagging"></a>익스텐트 태그 지정

익스텐타수와 함께 저장된 메타데이터의 일부로 Kusto는 여러 선택적 *익스텐트 태그를* 범위에 첨부하는 것을 지원합니다. 익스텐트 태그(또는 단순히 *태그)는*익스텐트와 연결된 문자열입니다. [.show 익스텐트](extents-commands.md#show-extents) 명령을 사용하여 익스와 연결된 태그를 볼 수 [있으며, 익스텐트 태그()](../query/extenttagsfunction.md) 함수를 사용하여 레코드와 연결된 태그를 익스텐트에서 볼 수 있습니다.
익스텐트 태그를 사용하여 익스텐트의 모든 데이터와 관련된 속성을 효율적으로 설명할 수 있습니다.
예를 들어 수집 하는 동안 수집 하는 데이터의 소스를 나타내는 익스텐트 태그를 추가할 수 있습니다., 나중에 해당 태그를 사용 하 여. 데이터를 설명할 때 둘 이상의 익스텐스가 병합될 때 관련 태그도 병합되는 익스텐트의 태그를 병합하는 익스텐트의 모든 익스텐트 태그의 결합이 됩니다.

Kusto는 값이 *서식 접두사* *접미사가* *있는* 모든 익스텐트 태그에 특별한 의미를 할당합니다.

* `drop-by:`
* `ingest-by:`

## <a name="drop-by-extent-tags"></a>'드롭 바이:' 익스텐트 태그

**`drop-by:`** 접두사로 시작하는 태그는 병합할 다른 익스텐스를 제어하는 데 사용할 수 있습니다. 지정된 `drop-by:` 태그가 있는 익스텐트는 함께 병합할 수 있지만 다른 익스텐스와 병합되지는 않습니다. 이렇게 하면 사용자는 다음 명령과 같이 `drop-by:` 태그에 따라 익스텐을 삭제하는 명령을 내릴 수 있습니다.

```kusto
.ingest ... with @'{"tags":"[\"drop-by:2016-02-17\"]"}'

.drop extents <| .show table MyTable extents where tags has "drop-by:2016-02-17" 
```

### <a name="performance-notes"></a>성능 노트

* 태그를 과도하게 `drop-by` 사용하는 것은 권장되지 않습니다. 위에서 언급한 방식으로 데이터를 삭제하는 지원은 드물게 발생하는 이벤트에 대한 지원이며 레코드 수준 데이터를 대체하기 위한 것이 아니며 이러한 방식으로 태그가 지정된 데이터가 "부피가 커"라는 사실에 크게 의존합니다. 각 레코드 또는 소수의 레코드에 대해 다른 태그를 지정하려고 하면 성능에 심각한 영향을 줄 수 있습니다.
* 데이터를 수집한 후 이러한 태그가 어느 정도 필요하지 않은 경우 [태그를 삭제하는](extents-commands.md#drop-extent-tags)것이 좋습니다.

## <a name="ingest-by-extent-tags"></a>'인제스트바이:' 익스텐트 태그

**`ingest-by:`** 접두사로 시작하는 태그를 사용하여 데이터를 한 번만 수집할 수 있습니다. 사용자는 `ingest-by:` **`ingestIfNotExists`** 속성을 사용하여 이 특정 태그에 이미 익스텐디가 있는 경우 데이터를 수집하지 못하도록 하는 인제스트 명령을 내릴 수 있습니다.
둘 다의 `tags` `ingestIfNotExists` 값과 JSON으로 직렬화된 문자열의 배열입니다.

다음 예제에서는 데이터를 한 번만 수집합니다(2번째 및 3번째 명령은 아무 것도 수행하지 않습니다).

```kusto
.ingest ... with (tags = '["ingest-by:2016-02-17"]')

.ingest ... with (ingestIfNotExists = '["2016-02-17"]')

.ingest ... with (ingestIfNotExists = '["2016-02-17"]', tags = '["ingest-by:2016-02-17"]')
```

> [!NOTE]
> 일반적인 경우, 인제스트 명령은 태그와 `ingest-by:` `ingestIfNotExists` 속성을 모두 포함할 수 있으며, 위의 3번째 명령에 표시된 대로 동일한 값으로 설정됩니다.

### <a name="performance-notes"></a>성능 노트

- 태그를 `ingest-by` 남용하는 것은 권장되지 않습니다.
Kusto에 데이터 중복이 있는 것으로 알려진 파이프라인의 경우 Kusto에 데이터를 수집하기 전에 가능한 한 많이 해결하고 `ingest-by` Kusto에 수집한 부품이 중복을 자체적으로 도입할 수 있는 경우에만 Kusto에서 태그를 사용하는 것이 좋습니다(예: 이미 진행 중인 수집 호출과 겹칠 수 있는 재시도 메커니즘이 있습니다). 각 들어오림 `ingest-by` 호출에 대해 고유한 태그를 설정하려고 하면 성능에 심각한 영향을 미칠 수 있습니다.
- 데이터를 수집한 후 이러한 태그가 어느 정도 필요하지 않은 경우 [태그를 삭제하는](extents-commands.md#drop-extent-tags)것이 좋습니다.